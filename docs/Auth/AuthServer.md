# Auth Server

The `AuthServer` is a utility class designed to handle the Authorization Code Flow locally. 

It simplifies the process of opening the user's browser for login and setting up a temporary local listener to capture the redirection code sent back by Spotify.

All functions are available via the `Spotify::AuthServer::` namespace.

---

## Table of Contents

- [Overview](#overview)
- [Function](#functions)
- [Example Usage](#example-usage)

---

## Overview
When using the Authorization Code Flow, Spotify redirects the user to a `redirect_uri` with a code parameter. 

The AuthServer:
- Automatically opens the system's default web browser.
- Spawns a lightweight, temporary HTTP server to "catch" the code.
- Optionally displays a custom "Success" HTML page to the user once authenticated.

---

## Functions

### `openBrowser(const std::string &url)`

Opens the system's default web browser to the specified URL. 

It contains cross-platform logic for Windows (`start`), macOS (`open`), and Linux (`xdg-open`).

| Parameter | Type                   | Description                                                 |
|-----------|------------------------|-------------------------------------------------------------|
| `url`     | `const std::string&`   | The Spotify Authorization URL generated by the `Auth` class |

**Throws**

`Spotify::Exception` if the system command fails to execute.

---

### `waitForCode(const std::string &auth_url, int port, const std::optional<std::filesystem::path> &html_file_path, bool suppress)`

Starts a temporary blocking HTTP server to listen for the Spotify callback. Once the code is captured, the server stops automatically.

| Parameter        | Type                       | Description                                                          |
|------------------|----------------------------|----------------------------------------------------------------------|
| `auth_url`       | `const std::string&`       | The local address to bind to (usually `"127.0.0.1"`)                 |
| `port`           | `int`                      | The port to listen on (must match your Spotify App dashboard)        |
| `html_file_path` | `std::optional<std::path>` | Optional path to a custom `.html` file to show the user upon success |
| `suppress`       | `bool`                     | If `true`, console messages are hidden                               |

**Returns**

A `std::string` containing the captured authorization code.

**Throws**
- `Spotify::NetworkException` if the port is already in use or binding fails.
- `Spotify::LogicException` if a custom HTML path is provided but the file cannot be read.

---

## Example Usage

### Basic Usage

This example demonstrates the most common way to use the server: starting it on localhost and waiting for the user to login via the browser.

```c++
// 1. Generate the URL using your Auth object
std::string url = auth.createAuthoriseURL("http://127.0.0.1:8888/callback", { Spotify::Scope::UserReadPrivate });

// 2. Open the browser
Spotify::AuthServer::openBrowser(url);

// 3. Wait for the code (This blocks until the user logs in)
std::string code = Spotify::AuthServer::waitForCode("127.0.0.1", 8888);

// 4. Exchange the code for a token
auth.exchangeCode(code);
```

### Using A Custom Success Page

If you want to show the user a branded "Thank you" page instead of the default library message, you can pass a path to an HTML file.

```c++
std::filesystem::path myPage = "./assets/success.html";

try {
    std::string code = Spotify::AuthServer::waitForCode("127.0.0.1", 8888, myPage);
    std::cout << "Code captured successfully!" << std::endl;
} catch (const Spotify::Exception& e) {
    std::cerr << e.what() << std::endl;
}
```

---

## Notes

- Blocking Call: `waitForCode` is a blocking function. Your application execution will pause there until the user completes the browser flow or an error occurs
- Port Matching: The `port` you pass must exactly match the port defined in your `redirect_uri` on the Spotify Developer Dashboard
- Callback Path: This server specifically listens on the `/callback` route. Ensure your Redirect URI ends in `/callback` (e.g., `http://127.0.0.1:8888/callback`)